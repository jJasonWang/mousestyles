from __future__ import print_function, absolute_import, division
import numpy as np

def find_limit_points(path_obj):
    r"""
    Returns a dictionary of the edge points of the path object.
    The dictionary containts min and max of each of the x, y coordinates in the path.

    Parameters
    ----------
    path_obj : pandas.DataFrame
        CT, CX, CY coordinates and homebase status.

    Returns
    -------
    edge points : dictionary
        contains edge points the path.

    Examples
    --------
    >>> movement = data.load_movement(1,2,1)
    >>> sep = path_index(movement, 1, 1)
    >>> path = movement[sep[2][0]:sep[2][1]+1]
    >>> limits = find_limit_points(path)
    """

    return( {'xmin' : np.min(path_obj.x) , 'xmax' : np.max(path_obj.x) , \
             'ymin' : np.min(path_obj.y) , 'ymax' : np.max(path_obj.y)} )

def compute_area_rectangle(limit_points):
    r"""
    Returns a numpy float object of the area of the rectange spanned by the path.
    Expecting limit_points to be the output of find_limit_points.

    Parameters
    ----------
    limit_points : dictionary
    	must contain xmin, xmax, ymin, ymax.

    Returns
    -------
    area : numpy float object
    	area of the rectange spanned by the path.

    Examples
    --------
    >>> movement = data.load_movement(1,2,1)
    >>> sep = path_index(movement, 1, 1)
    >>> path = movement[sep[2][0]:sep[2][1]+1]
    >>> limits = find_limit_points(path)
    >>> compute_area_rectangle(limits)
    """

    return( (limit_points['xmax']-limit_points['xmin']) * \
           (limit_points['ymax']-limit_points['ymin']) )

def find_center(limit_points):
    r"""
    Returns a dictionary of the center point of the path.
    Expecting limit_points to be the output of find_limit_points.

    Parameters
    ----------
    limit_points : dictionary
    	must contain xmin, xmax, ymin, ymax.

    Returns
    -------
    center point of the path : dictinoary
    	defined by the intersection of the diagonal lines of the
    	rectangle spanned by the path.

    Examples
    --------
    >>> movement = data.load_movement(1,2,1)
    >>> sep = path_index(movement, 1, 1)
    >>> path = movement[sep[2][0]:sep[2][1]+1]
    >>> limits = find_limit_points(path)
    >>> cent = find_center(limits)
    """

    return( { 'x' : (limit_points['xmin'] + limit_points['xmax'])/2 , \
             'y' : (limit_points['ymin'] + limit_points['ymax'])/2 } )

def unit_vector(vector):
    r""" Returns the unit vector of the vector.  """
    return(vector / np.linalg.norm(vector))

def angle_between(v1, v2):
    r"""
    Returns the angle in radians between vectors 'v1' and 'v2'::

    Examples
    --------
    >>> angle_between((1, 0, 0), (0, 1, 0))
    1.5707963267948966
    >>> angle_between((1, 0, 0), (1, 0, 0))
    0.0
    >>> angle_between((1, 0, 0), (-1, 0, 0))
    3.141592653589793
    """
    v1_u = unit_vector(v1)
    v2_u = unit_vector(v2)
    return np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))


def compute_radius_and_center_angle(path_obj, center):
    r"""
    Returns a dictionary containing radius and center angles of the path.
    Expecting center to be the output of find_center.

    Parameters
    ----------
    path_obj : pandas.DataFrame
        CT, CX, CY coordinates and homebase status.

    center : dictionary
        must contain x,y coordinates.

    Returns
    -------
    dictionary having the following elements.
    radius : list
        each element is the distance between center point and 
        each point in the path.

    center_anlges : list
        each element is the center angle generated by 2 adjacent 
        radius. The length equals to the length of the radius minus 1.

    Examples
    --------
    >>> movement = data.load_movement(1,2,1)
    >>> sep = path_index(movement, 1, 1)
    >>> path = movement[sep[2][0]:sep[2][1]+1]
    >>> limits = find_limit_points(path)
    >>> cent = find_center(limits)
    >>> r_and_ca = compute_radius_and_center_angle(path, cent)
    """

    indices = path_obj.index[:len(path_obj)]
    vectors = [ path_obj.loc[i,'x':'y'] - [center['x'],center['y']] for i in indices]
    center_angles = [angle_between(v1,v2) for v1,v2 in zip(vectors[1:], vectors[:len(vectors)])]
    radius = [np.linalg.norm(v) for v in vectors] 
    return({'radius': radius, 'center_angles': center_angles})

def compute_area_covered(r_and_theta):
    r"""
    Returns a numpy float object of the area spanned by the path.
    Expecting r_and_theta to be the output of compute_area_radius_and_center_angle.

    Parameters
    ----------
    r_and_theta : dictionary
        must contain radius and center angles. Expecting the output of 
        compute_area_radius_and_center_angle.

    Returns
    -------
    area : numpy float
        area computed by radius and center angles in the path.

    Examples
    --------
    >>> movement = data.load_movement(1,2,1)
    >>> sep = path_index(movement, 1, 1)
    >>> path = movement[sep[2][0]:sep[2][1]+1]
    >>> limits = find_limit_points(path)
    >>> cent = find_center(limits)
    >>> r_and_ca = compute_radius_and_center_angle(path, cent)
    >>> area = compute_area_covered(r_and_ca)
    """

    n = len(r_and_theta['radius'])
    zipped = zip(r_and_theta['radius'][1:], r_and_theta['radius'][:n], \
                 r_and_theta['center_angles'])
    areas = [ v1 * v2 * np.sin(theta) / 2 for v1,v2,theta in zipped]
    return(sum(areas))